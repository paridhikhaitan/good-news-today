{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tslib_1 = require(\"tslib\");\n\nvar PolygonMaskType_1 = require(\"../Enums/PolygonMaskType\");\n\nvar Particle_1 = require(\"./Particle\");\n\nvar PolygonMaskInlineArrangement_1 = require(\"../Enums/PolygonMaskInlineArrangement\");\n\nvar Utils_1 = require(\"./Utils/Utils\");\n\nvar Constants_1 = require(\"./Utils/Constants\");\n\nvar PolygonMask = function () {\n  function PolygonMask(container) {\n    this.container = container;\n    this.dimension = {\n      height: 0,\n      width: 0\n    };\n    this.paths = [];\n    this.path2DSupported = window.hasOwnProperty(\"Path2D\");\n  }\n\n  PolygonMask.prototype.checkInsidePolygon = function (position) {\n    var container = this.container;\n    var options = container.options;\n\n    if (!options.polygon.enable || options.polygon.type === PolygonMaskType_1.PolygonMaskType.none || options.polygon.type === PolygonMaskType_1.PolygonMaskType.inline) {\n      return true;\n    }\n\n    if (!this.raw) {\n      throw new Error(Constants_1.Constants.noPolygonFound);\n    }\n\n    var x = position ? position.x : Math.random() * container.canvas.size.width;\n    var y = position ? position.y : Math.random() * container.canvas.size.height;\n    var inside = false;\n\n    for (var i = 0, j = this.raw.length - 1; i < this.raw.length; j = i++) {\n      var xi = this.raw[i].x;\n      var yi = this.raw[i].y;\n      var xj = this.raw[j].x;\n      var yj = this.raw[j].y;\n      var intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;\n\n      if (intersect) {\n        inside = !inside;\n      }\n    }\n\n    if (options.polygon.type === PolygonMaskType_1.PolygonMaskType.inside) {\n      return inside;\n    } else if (options.polygon.type === PolygonMaskType_1.PolygonMaskType.outside) {\n      return !inside;\n    }\n\n    return false;\n  };\n\n  PolygonMask.prototype.redraw = function () {\n    var _this = this;\n\n    var container = this.container;\n    var options = container.options;\n\n    if (options.polygon.enable && options.polygon.type !== PolygonMaskType_1.PolygonMaskType.none) {\n      if (this.redrawTimeout) {\n        clearTimeout(this.redrawTimeout);\n      }\n\n      this.redrawTimeout = window.setTimeout(function () {\n        _this.parseSvgPathToPolygon().then(function (data) {\n          _this.raw = data;\n\n          _this.createPath2D();\n\n          container.particles.redraw();\n        });\n      }, 250);\n    }\n  };\n\n  PolygonMask.prototype.init = function () {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var container, options, _a;\n\n      return tslib_1.__generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            container = this.container;\n            options = container.options;\n            if (!(options.polygon.enable && options.polygon.url)) return [3, 2];\n            _a = this;\n            return [4, this.parseSvgPathToPolygon(options.polygon.url)];\n\n          case 1:\n            _a.raw = _b.sent();\n            this.createPath2D();\n            _b.label = 2;\n\n          case 2:\n            return [2];\n        }\n      });\n    });\n  };\n\n  PolygonMask.prototype.reset = function () {\n    delete this.raw;\n    this.paths = [];\n    delete this.svg;\n  };\n\n  PolygonMask.prototype.randomPointInPolygon = function () {\n    var container = this.container;\n    var options = container.options;\n    var position;\n\n    if (options.polygon.type === PolygonMaskType_1.PolygonMaskType.inline) {\n      switch (options.polygon.inline.arrangement) {\n        case PolygonMaskInlineArrangement_1.PolygonMaskInlineArrangement.randomPoint:\n          position = this.getRandomPointOnPolygonPath();\n          break;\n\n        case PolygonMaskInlineArrangement_1.PolygonMaskInlineArrangement.randomLength:\n          position = this.getRandomPointOnPolygonPathByLength();\n          break;\n\n        case PolygonMaskInlineArrangement_1.PolygonMaskInlineArrangement.equidistant:\n          position = this.getEquidistantPointOnPolygonPathByIndex(container.particles.count);\n          break;\n\n        case PolygonMaskInlineArrangement_1.PolygonMaskInlineArrangement.onePerPoint:\n        case PolygonMaskInlineArrangement_1.PolygonMaskInlineArrangement.perPoint:\n        default:\n          position = this.getPointOnPolygonPathByIndex(container.particles.count);\n      }\n    } else {\n      position = {\n        x: Math.random() * container.canvas.size.width,\n        y: Math.random() * container.canvas.size.height\n      };\n    }\n\n    if (this.checkInsidePolygon(position)) {\n      return position;\n    } else {\n      return this.randomPointInPolygon();\n    }\n  };\n\n  PolygonMask.prototype.parseSvgPathToPolygon = function (svgUrl) {\n    var _a;\n\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var container, options, url, req, xml, parser, doc, svgPaths, i, path, pxRatio, scale, position, polygonRaw, _i, _b, path, len, p, i, segment, absSeg, relSeg;\n\n      return tslib_1.__generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            container = this.container;\n            options = container.options;\n            url = svgUrl || options.polygon.url;\n            if (!(!this.paths.length || !this.svg)) return [3, 4];\n            return [4, fetch(url)];\n\n          case 1:\n            req = _c.sent();\n            if (!req.ok) return [3, 3];\n            return [4, req.text()];\n\n          case 2:\n            xml = _c.sent();\n            parser = new DOMParser();\n            doc = parser.parseFromString(xml, \"image/svg+xml\");\n            this.svg = doc.getElementsByTagName(\"svg\")[0];\n            svgPaths = doc.getElementsByTagName(\"path\");\n\n            for (i = 0; i < svgPaths.length; i++) {\n              path = svgPaths.item(i);\n\n              if (path) {\n                this.paths.push({\n                  element: path,\n                  length: path.getTotalLength()\n                });\n              }\n            }\n\n            return [3, 4];\n\n          case 3:\n            throw new Error(\"tsParticles Error - Error occurred during polygon mask download\");\n\n          case 4:\n            pxRatio = container.retina.pixelRatio;\n            scale = options.polygon.scale / pxRatio;\n            this.dimension.width = parseFloat(this.svg.getAttribute(\"width\") || \"0\") * scale;\n            this.dimension.height = parseFloat(this.svg.getAttribute(\"height\") || \"0\") * scale;\n            position = (_a = options.polygon.position) !== null && _a !== void 0 ? _a : {\n              x: 50,\n              y: 50\n            };\n            this.offset = {\n              x: container.canvas.size.width * position.x / (100 * pxRatio) - this.dimension.width / 2,\n              y: container.canvas.size.height * position.y / (100 * pxRatio) - this.dimension.height / 2\n            };\n            polygonRaw = [];\n\n            for (_i = 0, _b = this.paths; _i < _b.length; _i++) {\n              path = _b[_i];\n              len = path.element.pathSegList.numberOfItems;\n              p = {\n                x: 0,\n                y: 0\n              };\n\n              for (i = 0; i < len; i++) {\n                segment = path.element.pathSegList.getItem(i);\n\n                switch (segment.pathSegType) {\n                  case window.SVGPathSeg.PATHSEG_MOVETO_ABS:\n                  case window.SVGPathSeg.PATHSEG_LINETO_ABS:\n                  case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS:\n                  case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS:\n                  case window.SVGPathSeg.PATHSEG_ARC_ABS:\n                  case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS:\n                  case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS:\n                    absSeg = segment;\n                    p.x = absSeg.x;\n                    p.y = absSeg.y;\n                    break;\n\n                  case window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS:\n                    p.x = segment.x;\n                    break;\n\n                  case window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS:\n                    p.y = segment.y;\n                    break;\n\n                  case window.SVGPathSeg.PATHSEG_LINETO_REL:\n                  case window.SVGPathSeg.PATHSEG_MOVETO_REL:\n                  case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL:\n                  case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL:\n                  case window.SVGPathSeg.PATHSEG_ARC_REL:\n                  case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL:\n                  case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL:\n                    relSeg = segment;\n                    p.x += relSeg.x;\n                    p.y += relSeg.y;\n                    break;\n\n                  case window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL:\n                    p.x += segment.x;\n                    break;\n\n                  case window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL:\n                    p.y += segment.y;\n                    break;\n\n                  case window.SVGPathSeg.PATHSEG_UNKNOWN:\n                  case window.SVGPathSeg.PATHSEG_CLOSEPATH:\n                    continue;\n                }\n\n                polygonRaw.push({\n                  x: p.x * scale + this.offset.x,\n                  y: p.y * scale + this.offset.y\n                });\n              }\n            }\n\n            return [2, polygonRaw];\n        }\n      });\n    });\n  };\n\n  PolygonMask.prototype.drawPolygon = function () {\n    var container = this.container;\n    container.canvas.drawPolygonMask();\n  };\n\n  PolygonMask.prototype.drawPointsOnPolygonPath = function () {\n    var container = this.container;\n\n    if (this.raw) {\n      for (var _i = 0, _a = this.raw; _i < _a.length; _i++) {\n        var item = _a[_i];\n        var position = {\n          x: item.x,\n          y: item.y\n        };\n        container.particles.addParticle(new Particle_1.Particle(container, position));\n      }\n    }\n  };\n\n  PolygonMask.prototype.getRandomPointOnPolygonPath = function () {\n    if (!this.raw || !this.raw.length) throw new Error(Constants_1.Constants.noPolygonDataLoaded);\n    var coords = Utils_1.Utils.itemFromArray(this.raw);\n    return {\n      x: coords.x,\n      y: coords.y\n    };\n  };\n\n  PolygonMask.prototype.getRandomPointOnPolygonPathByLength = function () {\n    var _a, _b;\n\n    var container = this.container;\n    var options = container.options;\n    if (!this.raw || !this.raw.length || !this.paths.length) throw new Error(Constants_1.Constants.noPolygonDataLoaded);\n    var path = Utils_1.Utils.itemFromArray(this.paths);\n    var distance = Math.floor(Math.random() * path.length) + 1;\n    var point = path.element.getPointAtLength(distance);\n    return {\n      x: point.x * options.polygon.scale + (((_a = this.offset) === null || _a === void 0 ? void 0 : _a.x) || 0),\n      y: point.y * options.polygon.scale + (((_b = this.offset) === null || _b === void 0 ? void 0 : _b.y) || 0)\n    };\n  };\n\n  PolygonMask.prototype.getEquidistantPointOnPolygonPathByIndex = function (index) {\n    var _a, _b, _c, _d, _e, _f;\n\n    var container = this.container;\n    var options = container.options;\n    if (!this.raw || !this.raw.length || !this.paths.length) throw new Error(Constants_1.Constants.noPolygonDataLoaded);\n    var offset = 0;\n    var point;\n    var totalLength = this.paths.reduce(function (tot, path) {\n      return tot + path.length;\n    }, 0);\n    var distance = totalLength / options.particles.number.value;\n\n    for (var _i = 0, _g = this.paths; _i < _g.length; _i++) {\n      var path = _g[_i];\n      var pathDistance = distance * index - offset;\n\n      if (pathDistance <= path.length) {\n        point = path.element.getPointAtLength(pathDistance);\n        break;\n      } else {\n        offset += path.length;\n      }\n    }\n\n    return {\n      x: ((_a = point === null || point === void 0 ? void 0 : point.x) !== null && _a !== void 0 ? _a : 0) * options.polygon.scale + ((_c = (_b = this.offset) === null || _b === void 0 ? void 0 : _b.x) !== null && _c !== void 0 ? _c : 0),\n      y: ((_d = point === null || point === void 0 ? void 0 : point.y) !== null && _d !== void 0 ? _d : 0) * options.polygon.scale + ((_f = (_e = this.offset) === null || _e === void 0 ? void 0 : _e.y) !== null && _f !== void 0 ? _f : 0)\n    };\n  };\n\n  PolygonMask.prototype.getPointOnPolygonPathByIndex = function (index) {\n    if (!this.raw || !this.raw.length) throw new Error(Constants_1.Constants.noPolygonDataLoaded);\n    var coords = this.raw[index % this.raw.length];\n    return {\n      x: coords.x,\n      y: coords.y\n    };\n  };\n\n  PolygonMask.prototype.createPath2D = function () {\n    var _a;\n\n    if (!this.path2DSupported) {\n      return;\n    }\n\n    var _loop_1 = function (path) {\n      var pathData = (_a = path.element) === null || _a === void 0 ? void 0 : _a.getAttribute(\"d\");\n\n      if (pathData) {\n        var path2d = new Path2D(pathData);\n        var matrix = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\").createSVGMatrix();\n        var finalPath = new Path2D();\n        var transform = matrix.scale(this_1.container.options.polygon.scale);\n\n        if (finalPath.addPath) {\n          finalPath.addPath(path2d, transform);\n          path.path2d = finalPath;\n        } else {\n          delete path.path2d;\n        }\n      } else {\n        delete path.path2d;\n      }\n\n      if (!path.path2d && this_1.raw) {\n        path.path2d = new Path2D();\n        path.path2d.moveTo(this_1.raw[0].x, this_1.raw[0].y);\n        this_1.raw.forEach(function (pos, i) {\n          var _a;\n\n          if (i > 0) {\n            (_a = path.path2d) === null || _a === void 0 ? void 0 : _a.lineTo(pos.x, pos.y);\n          }\n        });\n        path.path2d.closePath();\n      }\n    };\n\n    var this_1 = this;\n\n    for (var _i = 0, _b = this.paths; _i < _b.length; _i++) {\n      var path = _b[_i];\n\n      _loop_1(path);\n    }\n  };\n\n  return PolygonMask;\n}();\n\nexports.PolygonMask = PolygonMask;","map":{"version":3,"sources":["/Users/apple/Desktop/twilio/node_modules/tsparticles/dist/Classes/PolygonMask.js"],"names":["Object","defineProperty","exports","value","tslib_1","require","PolygonMaskType_1","Particle_1","PolygonMaskInlineArrangement_1","Utils_1","Constants_1","PolygonMask","container","dimension","height","width","paths","path2DSupported","window","hasOwnProperty","prototype","checkInsidePolygon","position","options","polygon","enable","type","PolygonMaskType","none","inline","raw","Error","Constants","noPolygonFound","x","Math","random","canvas","size","y","inside","i","j","length","xi","yi","xj","yj","intersect","outside","redraw","_this","redrawTimeout","clearTimeout","setTimeout","parseSvgPathToPolygon","then","data","createPath2D","particles","init","__awaiter","_a","__generator","_b","label","url","sent","reset","svg","randomPointInPolygon","arrangement","PolygonMaskInlineArrangement","randomPoint","getRandomPointOnPolygonPath","randomLength","getRandomPointOnPolygonPathByLength","equidistant","getEquidistantPointOnPolygonPathByIndex","count","onePerPoint","perPoint","getPointOnPolygonPathByIndex","svgUrl","req","xml","parser","doc","svgPaths","path","pxRatio","scale","polygonRaw","_i","len","p","segment","absSeg","relSeg","_c","fetch","ok","text","DOMParser","parseFromString","getElementsByTagName","item","push","element","getTotalLength","retina","pixelRatio","parseFloat","getAttribute","offset","pathSegList","numberOfItems","getItem","pathSegType","SVGPathSeg","PATHSEG_MOVETO_ABS","PATHSEG_LINETO_ABS","PATHSEG_CURVETO_CUBIC_ABS","PATHSEG_CURVETO_QUADRATIC_ABS","PATHSEG_ARC_ABS","PATHSEG_CURVETO_CUBIC_SMOOTH_ABS","PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS","PATHSEG_LINETO_HORIZONTAL_ABS","PATHSEG_LINETO_VERTICAL_ABS","PATHSEG_LINETO_REL","PATHSEG_MOVETO_REL","PATHSEG_CURVETO_CUBIC_REL","PATHSEG_CURVETO_QUADRATIC_REL","PATHSEG_ARC_REL","PATHSEG_CURVETO_CUBIC_SMOOTH_REL","PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL","PATHSEG_LINETO_HORIZONTAL_REL","PATHSEG_LINETO_VERTICAL_REL","PATHSEG_UNKNOWN","PATHSEG_CLOSEPATH","drawPolygon","drawPolygonMask","drawPointsOnPolygonPath","addParticle","Particle","noPolygonDataLoaded","coords","Utils","itemFromArray","distance","floor","point","getPointAtLength","index","_d","_e","_f","totalLength","reduce","tot","number","_g","pathDistance","_loop_1","pathData","path2d","Path2D","matrix","document","createElementNS","createSVGMatrix","finalPath","transform","this_1","addPath","moveTo","forEach","pos","lineTo","closePath"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,IAAIC,OAAO,GAAGC,OAAO,CAAC,OAAD,CAArB;;AACA,IAAIC,iBAAiB,GAAGD,OAAO,CAAC,0BAAD,CAA/B;;AACA,IAAIE,UAAU,GAAGF,OAAO,CAAC,YAAD,CAAxB;;AACA,IAAIG,8BAA8B,GAAGH,OAAO,CAAC,uCAAD,CAA5C;;AACA,IAAII,OAAO,GAAGJ,OAAO,CAAC,eAAD,CAArB;;AACA,IAAIK,WAAW,GAAGL,OAAO,CAAC,mBAAD,CAAzB;;AACA,IAAIM,WAAW,GAAI,YAAY;AAC3B,WAASA,WAAT,CAAqBC,SAArB,EAAgC;AAC5B,SAAKA,SAAL,GAAiBA,SAAjB;AACA,SAAKC,SAAL,GAAiB;AACbC,MAAAA,MAAM,EAAE,CADK;AAEbC,MAAAA,KAAK,EAAE;AAFM,KAAjB;AAIA,SAAKC,KAAL,GAAa,EAAb;AACA,SAAKC,eAAL,GAAuBC,MAAM,CAACC,cAAP,CAAsB,QAAtB,CAAvB;AACH;;AACDR,EAAAA,WAAW,CAACS,SAAZ,CAAsBC,kBAAtB,GAA2C,UAAUC,QAAV,EAAoB;AAC3D,QAAIV,SAAS,GAAG,KAAKA,SAArB;AACA,QAAIW,OAAO,GAAGX,SAAS,CAACW,OAAxB;;AACA,QAAI,CAACA,OAAO,CAACC,OAAR,CAAgBC,MAAjB,IACAF,OAAO,CAACC,OAAR,CAAgBE,IAAhB,KAAyBpB,iBAAiB,CAACqB,eAAlB,CAAkCC,IAD3D,IAEAL,OAAO,CAACC,OAAR,CAAgBE,IAAhB,KAAyBpB,iBAAiB,CAACqB,eAAlB,CAAkCE,MAF/D,EAEuE;AACnE,aAAO,IAAP;AACH;;AACD,QAAI,CAAC,KAAKC,GAAV,EAAe;AACX,YAAM,IAAIC,KAAJ,CAAUrB,WAAW,CAACsB,SAAZ,CAAsBC,cAAhC,CAAN;AACH;;AACD,QAAIC,CAAC,GAAGZ,QAAQ,GAAGA,QAAQ,CAACY,CAAZ,GAAgBC,IAAI,CAACC,MAAL,KAAgBxB,SAAS,CAACyB,MAAV,CAAiBC,IAAjB,CAAsBvB,KAAtE;AACA,QAAIwB,CAAC,GAAGjB,QAAQ,GAAGA,QAAQ,CAACiB,CAAZ,GAAgBJ,IAAI,CAACC,MAAL,KAAgBxB,SAAS,CAACyB,MAAV,CAAiBC,IAAjB,CAAsBxB,MAAtE;AACA,QAAI0B,MAAM,GAAG,KAAb;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAG,KAAKZ,GAAL,CAASa,MAAT,GAAkB,CAAtC,EAAyCF,CAAC,GAAG,KAAKX,GAAL,CAASa,MAAtD,EAA8DD,CAAC,GAAGD,CAAC,EAAnE,EAAuE;AACnE,UAAIG,EAAE,GAAG,KAAKd,GAAL,CAASW,CAAT,EAAYP,CAArB;AACA,UAAIW,EAAE,GAAG,KAAKf,GAAL,CAASW,CAAT,EAAYF,CAArB;AACA,UAAIO,EAAE,GAAG,KAAKhB,GAAL,CAASY,CAAT,EAAYR,CAArB;AACA,UAAIa,EAAE,GAAG,KAAKjB,GAAL,CAASY,CAAT,EAAYH,CAArB;AACA,UAAIS,SAAS,GAAKH,EAAE,GAAGN,CAAN,KAAcQ,EAAE,GAAGR,CAApB,IAA4BL,CAAC,GAAG,CAACY,EAAE,GAAGF,EAAN,KAAaL,CAAC,GAAGM,EAAjB,KAAwBE,EAAE,GAAGF,EAA7B,IAAmCD,EAAnF;;AACA,UAAII,SAAJ,EAAe;AACXR,QAAAA,MAAM,GAAG,CAACA,MAAV;AACH;AACJ;;AACD,QAAIjB,OAAO,CAACC,OAAR,CAAgBE,IAAhB,KAAyBpB,iBAAiB,CAACqB,eAAlB,CAAkCa,MAA/D,EAAuE;AACnE,aAAOA,MAAP;AACH,KAFD,MAGK,IAAIjB,OAAO,CAACC,OAAR,CAAgBE,IAAhB,KAAyBpB,iBAAiB,CAACqB,eAAlB,CAAkCsB,OAA/D,EAAwE;AACzE,aAAO,CAACT,MAAR;AACH;;AACD,WAAO,KAAP;AACH,GA/BD;;AAgCA7B,EAAAA,WAAW,CAACS,SAAZ,CAAsB8B,MAAtB,GAA+B,YAAY;AACvC,QAAIC,KAAK,GAAG,IAAZ;;AACA,QAAIvC,SAAS,GAAG,KAAKA,SAArB;AACA,QAAIW,OAAO,GAAGX,SAAS,CAACW,OAAxB;;AACA,QAAIA,OAAO,CAACC,OAAR,CAAgBC,MAAhB,IAA0BF,OAAO,CAACC,OAAR,CAAgBE,IAAhB,KAAyBpB,iBAAiB,CAACqB,eAAlB,CAAkCC,IAAzF,EAA+F;AAC3F,UAAI,KAAKwB,aAAT,EAAwB;AACpBC,QAAAA,YAAY,CAAC,KAAKD,aAAN,CAAZ;AACH;;AACD,WAAKA,aAAL,GAAqBlC,MAAM,CAACoC,UAAP,CAAkB,YAAY;AAC/CH,QAAAA,KAAK,CAACI,qBAAN,GAA8BC,IAA9B,CAAmC,UAAUC,IAAV,EAAgB;AAC/CN,UAAAA,KAAK,CAACrB,GAAN,GAAY2B,IAAZ;;AACAN,UAAAA,KAAK,CAACO,YAAN;;AACA9C,UAAAA,SAAS,CAAC+C,SAAV,CAAoBT,MAApB;AACH,SAJD;AAKH,OANoB,EAMlB,GANkB,CAArB;AAOH;AACJ,GAhBD;;AAiBAvC,EAAAA,WAAW,CAACS,SAAZ,CAAsBwC,IAAtB,GAA6B,YAAY;AACrC,WAAOxD,OAAO,CAACyD,SAAR,CAAkB,IAAlB,EAAwB,KAAK,CAA7B,EAAgC,KAAK,CAArC,EAAwC,YAAY;AACvD,UAAIjD,SAAJ,EAAeW,OAAf,EAAwBuC,EAAxB;;AACA,aAAO1D,OAAO,CAAC2D,WAAR,CAAoB,IAApB,EAA0B,UAAUC,EAAV,EAAc;AAC3C,gBAAQA,EAAE,CAACC,KAAX;AACI,eAAK,CAAL;AACIrD,YAAAA,SAAS,GAAG,KAAKA,SAAjB;AACAW,YAAAA,OAAO,GAAGX,SAAS,CAACW,OAApB;AACA,gBAAI,EAAEA,OAAO,CAACC,OAAR,CAAgBC,MAAhB,IAA0BF,OAAO,CAACC,OAAR,CAAgB0C,GAA5C,CAAJ,EAAsD,OAAO,CAAC,CAAD,EAAI,CAAJ,CAAP;AACtDJ,YAAAA,EAAE,GAAG,IAAL;AACA,mBAAO,CAAC,CAAD,EAAI,KAAKP,qBAAL,CAA2BhC,OAAO,CAACC,OAAR,CAAgB0C,GAA3C,CAAJ,CAAP;;AACJ,eAAK,CAAL;AACIJ,YAAAA,EAAE,CAAChC,GAAH,GAASkC,EAAE,CAACG,IAAH,EAAT;AACA,iBAAKT,YAAL;AACAM,YAAAA,EAAE,CAACC,KAAH,GAAW,CAAX;;AACJ,eAAK,CAAL;AAAQ,mBAAO,CAAC,CAAD,CAAP;AAXZ;AAaH,OAdM,CAAP;AAeH,KAjBM,CAAP;AAkBH,GAnBD;;AAoBAtD,EAAAA,WAAW,CAACS,SAAZ,CAAsBgD,KAAtB,GAA8B,YAAY;AACtC,WAAO,KAAKtC,GAAZ;AACA,SAAKd,KAAL,GAAa,EAAb;AACA,WAAO,KAAKqD,GAAZ;AACH,GAJD;;AAKA1D,EAAAA,WAAW,CAACS,SAAZ,CAAsBkD,oBAAtB,GAA6C,YAAY;AACrD,QAAI1D,SAAS,GAAG,KAAKA,SAArB;AACA,QAAIW,OAAO,GAAGX,SAAS,CAACW,OAAxB;AACA,QAAID,QAAJ;;AACA,QAAIC,OAAO,CAACC,OAAR,CAAgBE,IAAhB,KAAyBpB,iBAAiB,CAACqB,eAAlB,CAAkCE,MAA/D,EAAuE;AACnE,cAAQN,OAAO,CAACC,OAAR,CAAgBK,MAAhB,CAAuB0C,WAA/B;AACI,aAAK/D,8BAA8B,CAACgE,4BAA/B,CAA4DC,WAAjE;AACInD,UAAAA,QAAQ,GAAG,KAAKoD,2BAAL,EAAX;AACA;;AACJ,aAAKlE,8BAA8B,CAACgE,4BAA/B,CAA4DG,YAAjE;AACIrD,UAAAA,QAAQ,GAAG,KAAKsD,mCAAL,EAAX;AACA;;AACJ,aAAKpE,8BAA8B,CAACgE,4BAA/B,CAA4DK,WAAjE;AACIvD,UAAAA,QAAQ,GAAG,KAAKwD,uCAAL,CAA6ClE,SAAS,CAAC+C,SAAV,CAAoBoB,KAAjE,CAAX;AACA;;AACJ,aAAKvE,8BAA8B,CAACgE,4BAA/B,CAA4DQ,WAAjE;AACA,aAAKxE,8BAA8B,CAACgE,4BAA/B,CAA4DS,QAAjE;AACA;AACI3D,UAAAA,QAAQ,GAAG,KAAK4D,4BAAL,CAAkCtE,SAAS,CAAC+C,SAAV,CAAoBoB,KAAtD,CAAX;AAbR;AAeH,KAhBD,MAiBK;AACDzD,MAAAA,QAAQ,GAAG;AACPY,QAAAA,CAAC,EAAEC,IAAI,CAACC,MAAL,KAAgBxB,SAAS,CAACyB,MAAV,CAAiBC,IAAjB,CAAsBvB,KADlC;AAEPwB,QAAAA,CAAC,EAAEJ,IAAI,CAACC,MAAL,KAAgBxB,SAAS,CAACyB,MAAV,CAAiBC,IAAjB,CAAsBxB;AAFlC,OAAX;AAIH;;AACD,QAAI,KAAKO,kBAAL,CAAwBC,QAAxB,CAAJ,EAAuC;AACnC,aAAOA,QAAP;AACH,KAFD,MAGK;AACD,aAAO,KAAKgD,oBAAL,EAAP;AACH;AACJ,GAjCD;;AAkCA3D,EAAAA,WAAW,CAACS,SAAZ,CAAsBmC,qBAAtB,GAA8C,UAAU4B,MAAV,EAAkB;AAC5D,QAAIrB,EAAJ;;AACA,WAAO1D,OAAO,CAACyD,SAAR,CAAkB,IAAlB,EAAwB,KAAK,CAA7B,EAAgC,KAAK,CAArC,EAAwC,YAAY;AACvD,UAAIjD,SAAJ,EAAeW,OAAf,EAAwB2C,GAAxB,EAA6BkB,GAA7B,EAAkCC,GAAlC,EAAuCC,MAAvC,EAA+CC,GAA/C,EAAoDC,QAApD,EAA8D/C,CAA9D,EAAiEgD,IAAjE,EAAuEC,OAAvE,EAAgFC,KAAhF,EAAuFrE,QAAvF,EAAiGsE,UAAjG,EAA6GC,EAA7G,EAAiH7B,EAAjH,EAAqHyB,IAArH,EAA2HK,GAA3H,EAAgIC,CAAhI,EAAmItD,CAAnI,EAAsIuD,OAAtI,EAA+IC,MAA/I,EAAuJC,MAAvJ;;AACA,aAAO9F,OAAO,CAAC2D,WAAR,CAAoB,IAApB,EAA0B,UAAUoC,EAAV,EAAc;AAC3C,gBAAQA,EAAE,CAAClC,KAAX;AACI,eAAK,CAAL;AACIrD,YAAAA,SAAS,GAAG,KAAKA,SAAjB;AACAW,YAAAA,OAAO,GAAGX,SAAS,CAACW,OAApB;AACA2C,YAAAA,GAAG,GAAGiB,MAAM,IAAI5D,OAAO,CAACC,OAAR,CAAgB0C,GAAhC;AACA,gBAAI,EAAE,CAAC,KAAKlD,KAAL,CAAW2B,MAAZ,IAAsB,CAAC,KAAK0B,GAA9B,CAAJ,EAAwC,OAAO,CAAC,CAAD,EAAI,CAAJ,CAAP;AACxC,mBAAO,CAAC,CAAD,EAAI+B,KAAK,CAAClC,GAAD,CAAT,CAAP;;AACJ,eAAK,CAAL;AACIkB,YAAAA,GAAG,GAAGe,EAAE,CAAChC,IAAH,EAAN;AACA,gBAAI,CAACiB,GAAG,CAACiB,EAAT,EAAa,OAAO,CAAC,CAAD,EAAI,CAAJ,CAAP;AACb,mBAAO,CAAC,CAAD,EAAIjB,GAAG,CAACkB,IAAJ,EAAJ,CAAP;;AACJ,eAAK,CAAL;AACIjB,YAAAA,GAAG,GAAGc,EAAE,CAAChC,IAAH,EAAN;AACAmB,YAAAA,MAAM,GAAG,IAAIiB,SAAJ,EAAT;AACAhB,YAAAA,GAAG,GAAGD,MAAM,CAACkB,eAAP,CAAuBnB,GAAvB,EAA4B,eAA5B,CAAN;AACA,iBAAKhB,GAAL,GAAWkB,GAAG,CAACkB,oBAAJ,CAAyB,KAAzB,EAAgC,CAAhC,CAAX;AACAjB,YAAAA,QAAQ,GAAGD,GAAG,CAACkB,oBAAJ,CAAyB,MAAzB,CAAX;;AACA,iBAAKhE,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG+C,QAAQ,CAAC7C,MAAzB,EAAiCF,CAAC,EAAlC,EAAsC;AAClCgD,cAAAA,IAAI,GAAGD,QAAQ,CAACkB,IAAT,CAAcjE,CAAd,CAAP;;AACA,kBAAIgD,IAAJ,EAAU;AACN,qBAAKzE,KAAL,CAAW2F,IAAX,CAAgB;AACZC,kBAAAA,OAAO,EAAEnB,IADG;AAEZ9C,kBAAAA,MAAM,EAAE8C,IAAI,CAACoB,cAAL;AAFI,iBAAhB;AAIH;AACJ;;AACD,mBAAO,CAAC,CAAD,EAAI,CAAJ,CAAP;;AACJ,eAAK,CAAL;AAAQ,kBAAM,IAAI9E,KAAJ,CAAU,iEAAV,CAAN;;AACR,eAAK,CAAL;AACI2D,YAAAA,OAAO,GAAG9E,SAAS,CAACkG,MAAV,CAAiBC,UAA3B;AACApB,YAAAA,KAAK,GAAGpE,OAAO,CAACC,OAAR,CAAgBmE,KAAhB,GAAwBD,OAAhC;AACA,iBAAK7E,SAAL,CAAeE,KAAf,GAAuBiG,UAAU,CAAC,KAAK3C,GAAL,CAAS4C,YAAT,CAAsB,OAAtB,KAAkC,GAAnC,CAAV,GAAoDtB,KAA3E;AACA,iBAAK9E,SAAL,CAAeC,MAAf,GAAwBkG,UAAU,CAAC,KAAK3C,GAAL,CAAS4C,YAAT,CAAsB,QAAtB,KAAmC,GAApC,CAAV,GAAqDtB,KAA7E;AACArE,YAAAA,QAAQ,GAAG,CAACwC,EAAE,GAAGvC,OAAO,CAACC,OAAR,CAAgBF,QAAtB,MAAoC,IAApC,IAA4CwC,EAAE,KAAK,KAAK,CAAxD,GAA4DA,EAA5D,GAAiE;AACxE5B,cAAAA,CAAC,EAAE,EADqE;AAExEK,cAAAA,CAAC,EAAE;AAFqE,aAA5E;AAIA,iBAAK2E,MAAL,GAAc;AACVhF,cAAAA,CAAC,EAAEtB,SAAS,CAACyB,MAAV,CAAiBC,IAAjB,CAAsBvB,KAAtB,GAA8BO,QAAQ,CAACY,CAAvC,IAA4C,MAAMwD,OAAlD,IAA6D,KAAK7E,SAAL,CAAeE,KAAf,GAAuB,CAD7E;AAEVwB,cAAAA,CAAC,EAAE3B,SAAS,CAACyB,MAAV,CAAiBC,IAAjB,CAAsBxB,MAAtB,GAA+BQ,QAAQ,CAACiB,CAAxC,IAA6C,MAAMmD,OAAnD,IAA8D,KAAK7E,SAAL,CAAeC,MAAf,GAAwB;AAF/E,aAAd;AAIA8E,YAAAA,UAAU,GAAG,EAAb;;AACA,iBAAKC,EAAE,GAAG,CAAL,EAAQ7B,EAAE,GAAG,KAAKhD,KAAvB,EAA8B6E,EAAE,GAAG7B,EAAE,CAACrB,MAAtC,EAA8CkD,EAAE,EAAhD,EAAoD;AAChDJ,cAAAA,IAAI,GAAGzB,EAAE,CAAC6B,EAAD,CAAT;AACAC,cAAAA,GAAG,GAAGL,IAAI,CAACmB,OAAL,CAAaO,WAAb,CAAyBC,aAA/B;AACArB,cAAAA,CAAC,GAAG;AACA7D,gBAAAA,CAAC,EAAE,CADH;AAEAK,gBAAAA,CAAC,EAAE;AAFH,eAAJ;;AAIA,mBAAKE,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGqD,GAAhB,EAAqBrD,CAAC,EAAtB,EAA0B;AACtBuD,gBAAAA,OAAO,GAAGP,IAAI,CAACmB,OAAL,CAAaO,WAAb,CAAyBE,OAAzB,CAAiC5E,CAAjC,CAAV;;AACA,wBAAQuD,OAAO,CAACsB,WAAhB;AACI,uBAAKpG,MAAM,CAACqG,UAAP,CAAkBC,kBAAvB;AACA,uBAAKtG,MAAM,CAACqG,UAAP,CAAkBE,kBAAvB;AACA,uBAAKvG,MAAM,CAACqG,UAAP,CAAkBG,yBAAvB;AACA,uBAAKxG,MAAM,CAACqG,UAAP,CAAkBI,6BAAvB;AACA,uBAAKzG,MAAM,CAACqG,UAAP,CAAkBK,eAAvB;AACA,uBAAK1G,MAAM,CAACqG,UAAP,CAAkBM,gCAAvB;AACA,uBAAK3G,MAAM,CAACqG,UAAP,CAAkBO,oCAAvB;AACI7B,oBAAAA,MAAM,GAAGD,OAAT;AACAD,oBAAAA,CAAC,CAAC7D,CAAF,GAAM+D,MAAM,CAAC/D,CAAb;AACA6D,oBAAAA,CAAC,CAACxD,CAAF,GAAM0D,MAAM,CAAC1D,CAAb;AACA;;AACJ,uBAAKrB,MAAM,CAACqG,UAAP,CAAkBQ,6BAAvB;AACIhC,oBAAAA,CAAC,CAAC7D,CAAF,GAAM8D,OAAO,CAAC9D,CAAd;AACA;;AACJ,uBAAKhB,MAAM,CAACqG,UAAP,CAAkBS,2BAAvB;AACIjC,oBAAAA,CAAC,CAACxD,CAAF,GAAMyD,OAAO,CAACzD,CAAd;AACA;;AACJ,uBAAKrB,MAAM,CAACqG,UAAP,CAAkBU,kBAAvB;AACA,uBAAK/G,MAAM,CAACqG,UAAP,CAAkBW,kBAAvB;AACA,uBAAKhH,MAAM,CAACqG,UAAP,CAAkBY,yBAAvB;AACA,uBAAKjH,MAAM,CAACqG,UAAP,CAAkBa,6BAAvB;AACA,uBAAKlH,MAAM,CAACqG,UAAP,CAAkBc,eAAvB;AACA,uBAAKnH,MAAM,CAACqG,UAAP,CAAkBe,gCAAvB;AACA,uBAAKpH,MAAM,CAACqG,UAAP,CAAkBgB,oCAAvB;AACIrC,oBAAAA,MAAM,GAAGF,OAAT;AACAD,oBAAAA,CAAC,CAAC7D,CAAF,IAAOgE,MAAM,CAAChE,CAAd;AACA6D,oBAAAA,CAAC,CAACxD,CAAF,IAAO2D,MAAM,CAAC3D,CAAd;AACA;;AACJ,uBAAKrB,MAAM,CAACqG,UAAP,CAAkBiB,6BAAvB;AACIzC,oBAAAA,CAAC,CAAC7D,CAAF,IAAO8D,OAAO,CAAC9D,CAAf;AACA;;AACJ,uBAAKhB,MAAM,CAACqG,UAAP,CAAkBkB,2BAAvB;AACI1C,oBAAAA,CAAC,CAACxD,CAAF,IAAOyD,OAAO,CAACzD,CAAf;AACA;;AACJ,uBAAKrB,MAAM,CAACqG,UAAP,CAAkBmB,eAAvB;AACA,uBAAKxH,MAAM,CAACqG,UAAP,CAAkBoB,iBAAvB;AACI;AArCR;;AAuCA/C,gBAAAA,UAAU,CAACe,IAAX,CAAgB;AACZzE,kBAAAA,CAAC,EAAE6D,CAAC,CAAC7D,CAAF,GAAMyD,KAAN,GAAc,KAAKuB,MAAL,CAAYhF,CADjB;AAEZK,kBAAAA,CAAC,EAAEwD,CAAC,CAACxD,CAAF,GAAMoD,KAAN,GAAc,KAAKuB,MAAL,CAAY3E;AAFjB,iBAAhB;AAIH;AACJ;;AACD,mBAAO,CAAC,CAAD,EAAIqD,UAAJ,CAAP;AAhGR;AAkGH,OAnGM,CAAP;AAoGH,KAtGM,CAAP;AAuGH,GAzGD;;AA0GAjF,EAAAA,WAAW,CAACS,SAAZ,CAAsBwH,WAAtB,GAAoC,YAAY;AAC5C,QAAIhI,SAAS,GAAG,KAAKA,SAArB;AACAA,IAAAA,SAAS,CAACyB,MAAV,CAAiBwG,eAAjB;AACH,GAHD;;AAIAlI,EAAAA,WAAW,CAACS,SAAZ,CAAsB0H,uBAAtB,GAAgD,YAAY;AACxD,QAAIlI,SAAS,GAAG,KAAKA,SAArB;;AACA,QAAI,KAAKkB,GAAT,EAAc;AACV,WAAK,IAAI+D,EAAE,GAAG,CAAT,EAAY/B,EAAE,GAAG,KAAKhC,GAA3B,EAAgC+D,EAAE,GAAG/B,EAAE,CAACnB,MAAxC,EAAgDkD,EAAE,EAAlD,EAAsD;AAClD,YAAIa,IAAI,GAAG5C,EAAE,CAAC+B,EAAD,CAAb;AACA,YAAIvE,QAAQ,GAAG;AACXY,UAAAA,CAAC,EAAEwE,IAAI,CAACxE,CADG;AAEXK,UAAAA,CAAC,EAAEmE,IAAI,CAACnE;AAFG,SAAf;AAIA3B,QAAAA,SAAS,CAAC+C,SAAV,CAAoBoF,WAApB,CAAgC,IAAIxI,UAAU,CAACyI,QAAf,CAAwBpI,SAAxB,EAAmCU,QAAnC,CAAhC;AACH;AACJ;AACJ,GAZD;;AAaAX,EAAAA,WAAW,CAACS,SAAZ,CAAsBsD,2BAAtB,GAAoD,YAAY;AAC5D,QAAI,CAAC,KAAK5C,GAAN,IAAa,CAAC,KAAKA,GAAL,CAASa,MAA3B,EACI,MAAM,IAAIZ,KAAJ,CAAUrB,WAAW,CAACsB,SAAZ,CAAsBiH,mBAAhC,CAAN;AACJ,QAAIC,MAAM,GAAGzI,OAAO,CAAC0I,KAAR,CAAcC,aAAd,CAA4B,KAAKtH,GAAjC,CAAb;AACA,WAAO;AACHI,MAAAA,CAAC,EAAEgH,MAAM,CAAChH,CADP;AAEHK,MAAAA,CAAC,EAAE2G,MAAM,CAAC3G;AAFP,KAAP;AAIH,GARD;;AASA5B,EAAAA,WAAW,CAACS,SAAZ,CAAsBwD,mCAAtB,GAA4D,YAAY;AACpE,QAAId,EAAJ,EAAQE,EAAR;;AACA,QAAIpD,SAAS,GAAG,KAAKA,SAArB;AACA,QAAIW,OAAO,GAAGX,SAAS,CAACW,OAAxB;AACA,QAAI,CAAC,KAAKO,GAAN,IAAa,CAAC,KAAKA,GAAL,CAASa,MAAvB,IAAiC,CAAC,KAAK3B,KAAL,CAAW2B,MAAjD,EACI,MAAM,IAAIZ,KAAJ,CAAUrB,WAAW,CAACsB,SAAZ,CAAsBiH,mBAAhC,CAAN;AACJ,QAAIxD,IAAI,GAAGhF,OAAO,CAAC0I,KAAR,CAAcC,aAAd,CAA4B,KAAKpI,KAAjC,CAAX;AACA,QAAIqI,QAAQ,GAAGlH,IAAI,CAACmH,KAAL,CAAWnH,IAAI,CAACC,MAAL,KAAgBqD,IAAI,CAAC9C,MAAhC,IAA0C,CAAzD;AACA,QAAI4G,KAAK,GAAG9D,IAAI,CAACmB,OAAL,CAAa4C,gBAAb,CAA8BH,QAA9B,CAAZ;AACA,WAAO;AACHnH,MAAAA,CAAC,EAAEqH,KAAK,CAACrH,CAAN,GAAUX,OAAO,CAACC,OAAR,CAAgBmE,KAA1B,IAAmC,CAAC,CAAC7B,EAAE,GAAG,KAAKoD,MAAX,MAAuB,IAAvB,IAA+BpD,EAAE,KAAK,KAAK,CAA3C,GAA+C,KAAK,CAApD,GAAwDA,EAAE,CAAC5B,CAA5D,KAAkE,CAArG,CADA;AAEHK,MAAAA,CAAC,EAAEgH,KAAK,CAAChH,CAAN,GAAUhB,OAAO,CAACC,OAAR,CAAgBmE,KAA1B,IAAmC,CAAC,CAAC3B,EAAE,GAAG,KAAKkD,MAAX,MAAuB,IAAvB,IAA+BlD,EAAE,KAAK,KAAK,CAA3C,GAA+C,KAAK,CAApD,GAAwDA,EAAE,CAACzB,CAA5D,KAAkE,CAArG;AAFA,KAAP;AAIH,GAbD;;AAcA5B,EAAAA,WAAW,CAACS,SAAZ,CAAsB0D,uCAAtB,GAAgE,UAAU2E,KAAV,EAAiB;AAC7E,QAAI3F,EAAJ,EAAQE,EAAR,EAAYmC,EAAZ,EAAgBuD,EAAhB,EAAoBC,EAApB,EAAwBC,EAAxB;;AACA,QAAIhJ,SAAS,GAAG,KAAKA,SAArB;AACA,QAAIW,OAAO,GAAGX,SAAS,CAACW,OAAxB;AACA,QAAI,CAAC,KAAKO,GAAN,IAAa,CAAC,KAAKA,GAAL,CAASa,MAAvB,IAAiC,CAAC,KAAK3B,KAAL,CAAW2B,MAAjD,EACI,MAAM,IAAIZ,KAAJ,CAAUrB,WAAW,CAACsB,SAAZ,CAAsBiH,mBAAhC,CAAN;AACJ,QAAI/B,MAAM,GAAG,CAAb;AACA,QAAIqC,KAAJ;AACA,QAAIM,WAAW,GAAG,KAAK7I,KAAL,CAAW8I,MAAX,CAAkB,UAAUC,GAAV,EAAetE,IAAf,EAAqB;AAAE,aAAOsE,GAAG,GAAGtE,IAAI,CAAC9C,MAAlB;AAA2B,KAApE,EAAsE,CAAtE,CAAlB;AACA,QAAI0G,QAAQ,GAAGQ,WAAW,GAAGtI,OAAO,CAACoC,SAAR,CAAkBqG,MAAlB,CAAyB7J,KAAtD;;AACA,SAAK,IAAI0F,EAAE,GAAG,CAAT,EAAYoE,EAAE,GAAG,KAAKjJ,KAA3B,EAAkC6E,EAAE,GAAGoE,EAAE,CAACtH,MAA1C,EAAkDkD,EAAE,EAApD,EAAwD;AACpD,UAAIJ,IAAI,GAAGwE,EAAE,CAACpE,EAAD,CAAb;AACA,UAAIqE,YAAY,GAAGb,QAAQ,GAAGI,KAAX,GAAmBvC,MAAtC;;AACA,UAAIgD,YAAY,IAAIzE,IAAI,CAAC9C,MAAzB,EAAiC;AAC7B4G,QAAAA,KAAK,GAAG9D,IAAI,CAACmB,OAAL,CAAa4C,gBAAb,CAA8BU,YAA9B,CAAR;AACA;AACH,OAHD,MAIK;AACDhD,QAAAA,MAAM,IAAIzB,IAAI,CAAC9C,MAAf;AACH;AACJ;;AACD,WAAO;AACHT,MAAAA,CAAC,EAAE,CAAC,CAAC4B,EAAE,GAAGyF,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAK,KAAK,CAAjC,GAAqC,KAAK,CAA1C,GAA8CA,KAAK,CAACrH,CAA1D,MAAiE,IAAjE,IAAyE4B,EAAE,KAAK,KAAK,CAArF,GAAyFA,EAAzF,GAA8F,CAA/F,IAAoGvC,OAAO,CAACC,OAAR,CAAgBmE,KAApH,IAA6H,CAACQ,EAAE,GAAG,CAACnC,EAAE,GAAG,KAAKkD,MAAX,MAAuB,IAAvB,IAA+BlD,EAAE,KAAK,KAAK,CAA3C,GAA+C,KAAK,CAApD,GAAwDA,EAAE,CAAC9B,CAAjE,MAAwE,IAAxE,IAAgFiE,EAAE,KAAK,KAAK,CAA5F,GAAgGA,EAAhG,GAAqG,CAAlO,CADA;AAEH5D,MAAAA,CAAC,EAAE,CAAC,CAACmH,EAAE,GAAGH,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAK,KAAK,CAAjC,GAAqC,KAAK,CAA1C,GAA8CA,KAAK,CAAChH,CAA1D,MAAiE,IAAjE,IAAyEmH,EAAE,KAAK,KAAK,CAArF,GAAyFA,EAAzF,GAA8F,CAA/F,IAAoGnI,OAAO,CAACC,OAAR,CAAgBmE,KAApH,IAA6H,CAACiE,EAAE,GAAG,CAACD,EAAE,GAAG,KAAKzC,MAAX,MAAuB,IAAvB,IAA+ByC,EAAE,KAAK,KAAK,CAA3C,GAA+C,KAAK,CAApD,GAAwDA,EAAE,CAACpH,CAAjE,MAAwE,IAAxE,IAAgFqH,EAAE,KAAK,KAAK,CAA5F,GAAgGA,EAAhG,GAAqG,CAAlO;AAFA,KAAP;AAIH,GAzBD;;AA0BAjJ,EAAAA,WAAW,CAACS,SAAZ,CAAsB8D,4BAAtB,GAAqD,UAAUuE,KAAV,EAAiB;AAClE,QAAI,CAAC,KAAK3H,GAAN,IAAa,CAAC,KAAKA,GAAL,CAASa,MAA3B,EACI,MAAM,IAAIZ,KAAJ,CAAUrB,WAAW,CAACsB,SAAZ,CAAsBiH,mBAAhC,CAAN;AACJ,QAAIC,MAAM,GAAG,KAAKpH,GAAL,CAAS2H,KAAK,GAAG,KAAK3H,GAAL,CAASa,MAA1B,CAAb;AACA,WAAO;AACHT,MAAAA,CAAC,EAAEgH,MAAM,CAAChH,CADP;AAEHK,MAAAA,CAAC,EAAE2G,MAAM,CAAC3G;AAFP,KAAP;AAIH,GARD;;AASA5B,EAAAA,WAAW,CAACS,SAAZ,CAAsBsC,YAAtB,GAAqC,YAAY;AAC7C,QAAII,EAAJ;;AACA,QAAI,CAAC,KAAK7C,eAAV,EAA2B;AACvB;AACH;;AACD,QAAIkJ,OAAO,GAAG,UAAU1E,IAAV,EAAgB;AAC1B,UAAI2E,QAAQ,GAAG,CAACtG,EAAE,GAAG2B,IAAI,CAACmB,OAAX,MAAwB,IAAxB,IAAgC9C,EAAE,KAAK,KAAK,CAA5C,GAAgD,KAAK,CAArD,GAAyDA,EAAE,CAACmD,YAAH,CAAgB,GAAhB,CAAxE;;AACA,UAAImD,QAAJ,EAAc;AACV,YAAIC,MAAM,GAAG,IAAIC,MAAJ,CAAWF,QAAX,CAAb;AACA,YAAIG,MAAM,GAAGC,QAAQ,CAACC,eAAT,CAAyB,4BAAzB,EAAuD,KAAvD,EAA8DC,eAA9D,EAAb;AACA,YAAIC,SAAS,GAAG,IAAIL,MAAJ,EAAhB;AACA,YAAIM,SAAS,GAAGL,MAAM,CAAC5E,KAAP,CAAakF,MAAM,CAACjK,SAAP,CAAiBW,OAAjB,CAAyBC,OAAzB,CAAiCmE,KAA9C,CAAhB;;AACA,YAAIgF,SAAS,CAACG,OAAd,EAAuB;AACnBH,UAAAA,SAAS,CAACG,OAAV,CAAkBT,MAAlB,EAA0BO,SAA1B;AACAnF,UAAAA,IAAI,CAAC4E,MAAL,GAAcM,SAAd;AACH,SAHD,MAIK;AACD,iBAAOlF,IAAI,CAAC4E,MAAZ;AACH;AACJ,OAZD,MAaK;AACD,eAAO5E,IAAI,CAAC4E,MAAZ;AACH;;AACD,UAAI,CAAC5E,IAAI,CAAC4E,MAAN,IAAgBQ,MAAM,CAAC/I,GAA3B,EAAgC;AAC5B2D,QAAAA,IAAI,CAAC4E,MAAL,GAAc,IAAIC,MAAJ,EAAd;AACA7E,QAAAA,IAAI,CAAC4E,MAAL,CAAYU,MAAZ,CAAmBF,MAAM,CAAC/I,GAAP,CAAW,CAAX,EAAcI,CAAjC,EAAoC2I,MAAM,CAAC/I,GAAP,CAAW,CAAX,EAAcS,CAAlD;AACAsI,QAAAA,MAAM,CAAC/I,GAAP,CAAWkJ,OAAX,CAAmB,UAAUC,GAAV,EAAexI,CAAf,EAAkB;AACjC,cAAIqB,EAAJ;;AACA,cAAIrB,CAAC,GAAG,CAAR,EAAW;AACP,aAACqB,EAAE,GAAG2B,IAAI,CAAC4E,MAAX,MAAuB,IAAvB,IAA+BvG,EAAE,KAAK,KAAK,CAA3C,GAA+C,KAAK,CAApD,GAAwDA,EAAE,CAACoH,MAAH,CAAUD,GAAG,CAAC/I,CAAd,EAAiB+I,GAAG,CAAC1I,CAArB,CAAxD;AACH;AACJ,SALD;AAMAkD,QAAAA,IAAI,CAAC4E,MAAL,CAAYc,SAAZ;AACH;AACJ,KA7BD;;AA8BA,QAAIN,MAAM,GAAG,IAAb;;AACA,SAAK,IAAIhF,EAAE,GAAG,CAAT,EAAY7B,EAAE,GAAG,KAAKhD,KAA3B,EAAkC6E,EAAE,GAAG7B,EAAE,CAACrB,MAA1C,EAAkDkD,EAAE,EAApD,EAAwD;AACpD,UAAIJ,IAAI,GAAGzB,EAAE,CAAC6B,EAAD,CAAb;;AACAsE,MAAAA,OAAO,CAAC1E,IAAD,CAAP;AACH;AACJ,GAxCD;;AAyCA,SAAO9E,WAAP;AACH,CArVkB,EAAnB;;AAsVAT,OAAO,CAACS,WAAR,GAAsBA,WAAtB","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar PolygonMaskType_1 = require(\"../Enums/PolygonMaskType\");\nvar Particle_1 = require(\"./Particle\");\nvar PolygonMaskInlineArrangement_1 = require(\"../Enums/PolygonMaskInlineArrangement\");\nvar Utils_1 = require(\"./Utils/Utils\");\nvar Constants_1 = require(\"./Utils/Constants\");\nvar PolygonMask = (function () {\n    function PolygonMask(container) {\n        this.container = container;\n        this.dimension = {\n            height: 0,\n            width: 0,\n        };\n        this.paths = [];\n        this.path2DSupported = window.hasOwnProperty(\"Path2D\");\n    }\n    PolygonMask.prototype.checkInsidePolygon = function (position) {\n        var container = this.container;\n        var options = container.options;\n        if (!options.polygon.enable ||\n            options.polygon.type === PolygonMaskType_1.PolygonMaskType.none ||\n            options.polygon.type === PolygonMaskType_1.PolygonMaskType.inline) {\n            return true;\n        }\n        if (!this.raw) {\n            throw new Error(Constants_1.Constants.noPolygonFound);\n        }\n        var x = position ? position.x : Math.random() * container.canvas.size.width;\n        var y = position ? position.y : Math.random() * container.canvas.size.height;\n        var inside = false;\n        for (var i = 0, j = this.raw.length - 1; i < this.raw.length; j = i++) {\n            var xi = this.raw[i].x;\n            var yi = this.raw[i].y;\n            var xj = this.raw[j].x;\n            var yj = this.raw[j].y;\n            var intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n            if (intersect) {\n                inside = !inside;\n            }\n        }\n        if (options.polygon.type === PolygonMaskType_1.PolygonMaskType.inside) {\n            return inside;\n        }\n        else if (options.polygon.type === PolygonMaskType_1.PolygonMaskType.outside) {\n            return !inside;\n        }\n        return false;\n    };\n    PolygonMask.prototype.redraw = function () {\n        var _this = this;\n        var container = this.container;\n        var options = container.options;\n        if (options.polygon.enable && options.polygon.type !== PolygonMaskType_1.PolygonMaskType.none) {\n            if (this.redrawTimeout) {\n                clearTimeout(this.redrawTimeout);\n            }\n            this.redrawTimeout = window.setTimeout(function () {\n                _this.parseSvgPathToPolygon().then(function (data) {\n                    _this.raw = data;\n                    _this.createPath2D();\n                    container.particles.redraw();\n                });\n            }, 250);\n        }\n    };\n    PolygonMask.prototype.init = function () {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var container, options, _a;\n            return tslib_1.__generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        container = this.container;\n                        options = container.options;\n                        if (!(options.polygon.enable && options.polygon.url)) return [3, 2];\n                        _a = this;\n                        return [4, this.parseSvgPathToPolygon(options.polygon.url)];\n                    case 1:\n                        _a.raw = _b.sent();\n                        this.createPath2D();\n                        _b.label = 2;\n                    case 2: return [2];\n                }\n            });\n        });\n    };\n    PolygonMask.prototype.reset = function () {\n        delete this.raw;\n        this.paths = [];\n        delete this.svg;\n    };\n    PolygonMask.prototype.randomPointInPolygon = function () {\n        var container = this.container;\n        var options = container.options;\n        var position;\n        if (options.polygon.type === PolygonMaskType_1.PolygonMaskType.inline) {\n            switch (options.polygon.inline.arrangement) {\n                case PolygonMaskInlineArrangement_1.PolygonMaskInlineArrangement.randomPoint:\n                    position = this.getRandomPointOnPolygonPath();\n                    break;\n                case PolygonMaskInlineArrangement_1.PolygonMaskInlineArrangement.randomLength:\n                    position = this.getRandomPointOnPolygonPathByLength();\n                    break;\n                case PolygonMaskInlineArrangement_1.PolygonMaskInlineArrangement.equidistant:\n                    position = this.getEquidistantPointOnPolygonPathByIndex(container.particles.count);\n                    break;\n                case PolygonMaskInlineArrangement_1.PolygonMaskInlineArrangement.onePerPoint:\n                case PolygonMaskInlineArrangement_1.PolygonMaskInlineArrangement.perPoint:\n                default:\n                    position = this.getPointOnPolygonPathByIndex(container.particles.count);\n            }\n        }\n        else {\n            position = {\n                x: Math.random() * container.canvas.size.width,\n                y: Math.random() * container.canvas.size.height,\n            };\n        }\n        if (this.checkInsidePolygon(position)) {\n            return position;\n        }\n        else {\n            return this.randomPointInPolygon();\n        }\n    };\n    PolygonMask.prototype.parseSvgPathToPolygon = function (svgUrl) {\n        var _a;\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var container, options, url, req, xml, parser, doc, svgPaths, i, path, pxRatio, scale, position, polygonRaw, _i, _b, path, len, p, i, segment, absSeg, relSeg;\n            return tslib_1.__generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        container = this.container;\n                        options = container.options;\n                        url = svgUrl || options.polygon.url;\n                        if (!(!this.paths.length || !this.svg)) return [3, 4];\n                        return [4, fetch(url)];\n                    case 1:\n                        req = _c.sent();\n                        if (!req.ok) return [3, 3];\n                        return [4, req.text()];\n                    case 2:\n                        xml = _c.sent();\n                        parser = new DOMParser();\n                        doc = parser.parseFromString(xml, \"image/svg+xml\");\n                        this.svg = doc.getElementsByTagName(\"svg\")[0];\n                        svgPaths = doc.getElementsByTagName(\"path\");\n                        for (i = 0; i < svgPaths.length; i++) {\n                            path = svgPaths.item(i);\n                            if (path) {\n                                this.paths.push({\n                                    element: path,\n                                    length: path.getTotalLength(),\n                                });\n                            }\n                        }\n                        return [3, 4];\n                    case 3: throw new Error(\"tsParticles Error - Error occurred during polygon mask download\");\n                    case 4:\n                        pxRatio = container.retina.pixelRatio;\n                        scale = options.polygon.scale / pxRatio;\n                        this.dimension.width = parseFloat(this.svg.getAttribute(\"width\") || \"0\") * scale;\n                        this.dimension.height = parseFloat(this.svg.getAttribute(\"height\") || \"0\") * scale;\n                        position = (_a = options.polygon.position) !== null && _a !== void 0 ? _a : {\n                            x: 50,\n                            y: 50,\n                        };\n                        this.offset = {\n                            x: container.canvas.size.width * position.x / (100 * pxRatio) - this.dimension.width / 2,\n                            y: container.canvas.size.height * position.y / (100 * pxRatio) - this.dimension.height / 2,\n                        };\n                        polygonRaw = [];\n                        for (_i = 0, _b = this.paths; _i < _b.length; _i++) {\n                            path = _b[_i];\n                            len = path.element.pathSegList.numberOfItems;\n                            p = {\n                                x: 0,\n                                y: 0,\n                            };\n                            for (i = 0; i < len; i++) {\n                                segment = path.element.pathSegList.getItem(i);\n                                switch (segment.pathSegType) {\n                                    case window.SVGPathSeg.PATHSEG_MOVETO_ABS:\n                                    case window.SVGPathSeg.PATHSEG_LINETO_ABS:\n                                    case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS:\n                                    case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS:\n                                    case window.SVGPathSeg.PATHSEG_ARC_ABS:\n                                    case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS:\n                                    case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS:\n                                        absSeg = segment;\n                                        p.x = absSeg.x;\n                                        p.y = absSeg.y;\n                                        break;\n                                    case window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS:\n                                        p.x = segment.x;\n                                        break;\n                                    case window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS:\n                                        p.y = segment.y;\n                                        break;\n                                    case window.SVGPathSeg.PATHSEG_LINETO_REL:\n                                    case window.SVGPathSeg.PATHSEG_MOVETO_REL:\n                                    case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL:\n                                    case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL:\n                                    case window.SVGPathSeg.PATHSEG_ARC_REL:\n                                    case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL:\n                                    case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL:\n                                        relSeg = segment;\n                                        p.x += relSeg.x;\n                                        p.y += relSeg.y;\n                                        break;\n                                    case window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL:\n                                        p.x += segment.x;\n                                        break;\n                                    case window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL:\n                                        p.y += segment.y;\n                                        break;\n                                    case window.SVGPathSeg.PATHSEG_UNKNOWN:\n                                    case window.SVGPathSeg.PATHSEG_CLOSEPATH:\n                                        continue;\n                                }\n                                polygonRaw.push({\n                                    x: p.x * scale + this.offset.x,\n                                    y: p.y * scale + this.offset.y,\n                                });\n                            }\n                        }\n                        return [2, polygonRaw];\n                }\n            });\n        });\n    };\n    PolygonMask.prototype.drawPolygon = function () {\n        var container = this.container;\n        container.canvas.drawPolygonMask();\n    };\n    PolygonMask.prototype.drawPointsOnPolygonPath = function () {\n        var container = this.container;\n        if (this.raw) {\n            for (var _i = 0, _a = this.raw; _i < _a.length; _i++) {\n                var item = _a[_i];\n                var position = {\n                    x: item.x,\n                    y: item.y,\n                };\n                container.particles.addParticle(new Particle_1.Particle(container, position));\n            }\n        }\n    };\n    PolygonMask.prototype.getRandomPointOnPolygonPath = function () {\n        if (!this.raw || !this.raw.length)\n            throw new Error(Constants_1.Constants.noPolygonDataLoaded);\n        var coords = Utils_1.Utils.itemFromArray(this.raw);\n        return {\n            x: coords.x,\n            y: coords.y,\n        };\n    };\n    PolygonMask.prototype.getRandomPointOnPolygonPathByLength = function () {\n        var _a, _b;\n        var container = this.container;\n        var options = container.options;\n        if (!this.raw || !this.raw.length || !this.paths.length)\n            throw new Error(Constants_1.Constants.noPolygonDataLoaded);\n        var path = Utils_1.Utils.itemFromArray(this.paths);\n        var distance = Math.floor(Math.random() * path.length) + 1;\n        var point = path.element.getPointAtLength(distance);\n        return {\n            x: point.x * options.polygon.scale + (((_a = this.offset) === null || _a === void 0 ? void 0 : _a.x) || 0),\n            y: point.y * options.polygon.scale + (((_b = this.offset) === null || _b === void 0 ? void 0 : _b.y) || 0),\n        };\n    };\n    PolygonMask.prototype.getEquidistantPointOnPolygonPathByIndex = function (index) {\n        var _a, _b, _c, _d, _e, _f;\n        var container = this.container;\n        var options = container.options;\n        if (!this.raw || !this.raw.length || !this.paths.length)\n            throw new Error(Constants_1.Constants.noPolygonDataLoaded);\n        var offset = 0;\n        var point;\n        var totalLength = this.paths.reduce(function (tot, path) { return tot + path.length; }, 0);\n        var distance = totalLength / options.particles.number.value;\n        for (var _i = 0, _g = this.paths; _i < _g.length; _i++) {\n            var path = _g[_i];\n            var pathDistance = distance * index - offset;\n            if (pathDistance <= path.length) {\n                point = path.element.getPointAtLength(pathDistance);\n                break;\n            }\n            else {\n                offset += path.length;\n            }\n        }\n        return {\n            x: ((_a = point === null || point === void 0 ? void 0 : point.x) !== null && _a !== void 0 ? _a : 0) * options.polygon.scale + ((_c = (_b = this.offset) === null || _b === void 0 ? void 0 : _b.x) !== null && _c !== void 0 ? _c : 0),\n            y: ((_d = point === null || point === void 0 ? void 0 : point.y) !== null && _d !== void 0 ? _d : 0) * options.polygon.scale + ((_f = (_e = this.offset) === null || _e === void 0 ? void 0 : _e.y) !== null && _f !== void 0 ? _f : 0),\n        };\n    };\n    PolygonMask.prototype.getPointOnPolygonPathByIndex = function (index) {\n        if (!this.raw || !this.raw.length)\n            throw new Error(Constants_1.Constants.noPolygonDataLoaded);\n        var coords = this.raw[index % this.raw.length];\n        return {\n            x: coords.x,\n            y: coords.y,\n        };\n    };\n    PolygonMask.prototype.createPath2D = function () {\n        var _a;\n        if (!this.path2DSupported) {\n            return;\n        }\n        var _loop_1 = function (path) {\n            var pathData = (_a = path.element) === null || _a === void 0 ? void 0 : _a.getAttribute(\"d\");\n            if (pathData) {\n                var path2d = new Path2D(pathData);\n                var matrix = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\").createSVGMatrix();\n                var finalPath = new Path2D();\n                var transform = matrix.scale(this_1.container.options.polygon.scale);\n                if (finalPath.addPath) {\n                    finalPath.addPath(path2d, transform);\n                    path.path2d = finalPath;\n                }\n                else {\n                    delete path.path2d;\n                }\n            }\n            else {\n                delete path.path2d;\n            }\n            if (!path.path2d && this_1.raw) {\n                path.path2d = new Path2D();\n                path.path2d.moveTo(this_1.raw[0].x, this_1.raw[0].y);\n                this_1.raw.forEach(function (pos, i) {\n                    var _a;\n                    if (i > 0) {\n                        (_a = path.path2d) === null || _a === void 0 ? void 0 : _a.lineTo(pos.x, pos.y);\n                    }\n                });\n                path.path2d.closePath();\n            }\n        };\n        var this_1 = this;\n        for (var _i = 0, _b = this.paths; _i < _b.length; _i++) {\n            var path = _b[_i];\n            _loop_1(path);\n        }\n    };\n    return PolygonMask;\n}());\nexports.PolygonMask = PolygonMask;\n"]},"metadata":{},"sourceType":"script"}